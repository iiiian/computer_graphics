<body bgcolor=black>
<center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

function Scene() {

this.vertexShader = `#version 300 es
in  vec3 aPos;
out vec3 vPos;
void main() {
   gl_Position = vec4(aPos, 1.);
   vPos = aPos;
}`;

this.fragmentShader = `#version 300 es
precision highp float;
uniform float uTime;
uniform vec3 uViewPoint;
in vec3 vPos;
out vec4 fragColor;

// Ray: V + r*W
// Sphere: center + radius
//
// return (t1, t2) if ray collides with sphere.
// else return (1001, 1000)
vec2 raySphere(vec3 V, vec3 W, vec4 S) {
    V -= S.xyz;
    float b = dot(V, W);
    float d = b * b - dot(V, V) + S.w * S.w;
    if (d < 0.)
        return vec2(1001., 1000.);
    return vec2(-b - sqrt(d), -b + sqrt(d));
}

// Try to create a wobbly sphere of water. Kind of fail....
// But it looks cool anyway.

const float PI = 3.14159265;
const float BASE_RADIUS = 0.7;
const float WOBBLE_AMPLITUDE = 0.06;

// compute wobble based on polar coor
float wobble(float theta, float phi) {
    return WOBBLE_AMPLITUDE * sin(theta * 3.0 + uTime * 1.2)
         * cos(phi * 2.5 - uTime * 0.8);
}

// polar coor back to normal direction
vec3 angleToDirection(float theta, float phi) {
    float sinPhi = sin(phi);
    return vec3(cos(theta) * sinPhi,
        sin(theta) * sinPhi,
        cos(phi));
}

// base radius + wobble radius
float radiusAt(float theta, float phi) {
    return BASE_RADIUS + wobble(theta, phi);
}

// wobble tip
vec3 surfacePoint(vec4 sphere, float theta, float phi) {
    return sphere.xyz + radiusAt(theta, phi) * angleToDirection(theta, phi);
}

vec3 surfaceNormal(vec4 sphere, float theta, float phi) {
    float eps = 0.01;
    float clampedPhi = clamp(phi, 0.001, PI - 0.001);
    vec3 p = surfacePoint(sphere, theta, clampedPhi);
    vec3 pTheta = surfacePoint(sphere, theta + eps, clampedPhi);
    vec3 pPhi = surfacePoint(sphere, theta, clamp(clampedPhi + eps, 0.001, PI - 0.001));
    vec3 tangentTheta = pTheta - p;
    vec3 tangentPhi = pPhi - p;
    return normalize(cross(tangentTheta, tangentPhi));
}

vec3 shade(vec3 N) {
    vec3 L1 = normalize(vec3(1.0, 1.0, 0.6));
    vec3 L2 = normalize(vec3(-0.6, 0.3, 1.0));
    vec3 baseColor = vec3(0.4, 0.55, 0.95);
    float diff = 0.2 + 0.7 * max(0.0, dot(N, L1)) + 0.4 * max(0.0, dot(N, L2));
    return baseColor * diff;
}

void main() {
    vec4 sphere = vec4(0.0, 0.0, 0.0, BASE_RADIUS + WOBBLE_AMPLITUDE);
    vec3 V = uViewPoint;
    vec3 W = normalize(vPos - V);

    vec2 tt = raySphere(V, W, sphere);
    if (!(tt.x < tt.y && tt.x > 0.0)) {
        fragColor = vec4(0.0);
        return;
    }

    vec3 probePoint = V + tt.x * W;
    vec3 probeDir = normalize(probePoint - sphere.xyz);
    float theta = atan(probeDir.y, probeDir.x);
    float phi = acos(clamp(probeDir.z, -1.0, 1.0));

    sphere.w = radiusAt(theta, phi);
    vec2 hit = raySphere(V, W, sphere);
    if (!(hit.x < hit.y && hit.x > 0.0)) {
        fragColor = vec4(0.0);
        return;
    }

    vec3 P = V + hit.x * W;
    vec3 dir = normalize(P - sphere.xyz);
    theta = atan(dir.y, dir.x);
    phi = acos(clamp(dir.z, -1.0, 1.0));

    vec3 N = surfaceNormal(sphere, theta, phi);
    if (dot(N, P - sphere.xyz) < 0.0)
        N = -N;

    vec3 color = shade(N);
    fragColor = vec4(sqrt(color), 1.0);
}
`;

let startTime = Date.now() / 1000;

this.update = viewPoint => {
   let time = Date.now() / 1000 - startTime;
   setUniform('1f', 'uTime', time);
   setUniform('3fv', 'uViewPoint', viewPoint);
}

}

gl_start(canvas, new Scene());
</script>
